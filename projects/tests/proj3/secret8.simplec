#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "template.h"

void Function(int start);
void Statement();
void Expression(int start, int end);

struct node
{
	char* str; //String Contained in Node
	struct node* next; //Next Node in the Structure

	int precedence; //Operator Precedence

	//char* varLocation; //Location of initialized variable

	char* type; // TERMINAL, VARIABLE, OPERATOR, KEYWORD
};

struct node *lexemesHead = NULL;
struct node *lexemesCurrent = NULL;

struct node *symbolTableHead = NULL;
struct node *symbolTableCurrent = NULL;

struct node *functionTableHead = NULL;
struct node *functionTableCurrent = NULL;

struct node *fucntionTermsHead = NULL;
struct node *functionTermsCurrent = NULL;

int GlobalCounter = 0;
int LabelCounter = 0;
int Returned = 0;

//Utilities.h

// Returns 1 if the strings are the same 0 otherwise
int CompareStrings(const char *a, const char *b)
{
	//printf("%s - s\n", b);
	int ca, cb;

	do {
		ca = (unsigned char)*a++;
		cb = (unsigned char)*b++;
	} while (ca == cb && ca != '\0');
	return (ca - cb) == 0 ? 1 : 0;
}

// Returns the number of characters in a base 10 number
int charCount(int num)
{
	int count = 1;

	while (num > 10)
	{
		num = num / 10;
		++count;
	}

	return ++count;
}

// Temporary Var Generation
char* createTerminalString()
{
	char* finalString = (char*)calloc(3 + charCount(++GlobalCounter), sizeof(char));
	char* tempString = (char*)calloc(1 + charCount(GlobalCounter), sizeof(char));
	sprintf(tempString, "%d", GlobalCounter);
	strcpy(finalString, "%t");
	strcat(finalString, tempString);

	free(tempString);
	return finalString;
}


//Structures.h

//Debugging
void printList(struct node* head)
{
	struct node *ptr = head;
	printf("\n[ ");

	//start from the beginning
	while (ptr != NULL)
	{
		printf("(%s) ", ptr->str);
		ptr = ptr->next;
	}

	printf(" ]\n");
}

void inqueueS(char* string, struct node** current, struct node** head)
{
	struct node *temp = (struct node*)calloc(1, sizeof(struct node));
	char *buffer = calloc(1, sizeof(string));
	strcpy(buffer, string);
	temp->str = buffer;
	temp->next = NULL;

	if (*head == NULL) // If there is no head set the head to temp
		(*head) = temp;
	else // If there is a head set the current.next to temp
		(*current)->next = temp;

	(*current) = temp; // Set the new current
}

void inqueueN(struct node* node, struct node** current, struct node** head)
{
	if (node == NULL)
	{
		printf("Inputing NULL error\n");
		return;
	}
	//printf("N, %s\n", node->str);
	node->next = NULL;

	if (*head == NULL) // If there is no head set the head to temp
		(*head) = node;
	else // If there is a head set the current.next to temp
		(*current)->next = node;

	(*current) = node; // Set the new current
}

struct node* dequeue(struct node** head, struct node** current, int index)
{
	int i;

	struct node *last = NULL;
	struct node *temp = (*head);

	if ((*head) == (*current))
	{
		(*current) = NULL;
	}

	for (i = 0; i < index; i++)
	{
		last = temp;
		temp = temp->next;
	}

	if (last == NULL)
	{
		(*head) = temp->next;
	}
	else
	{
		last->next = temp->next;
	}

	return temp;
}

struct node* peek(struct node** head, int index)
{
	int i;

	struct node *temp = (*head);

	for (i = 0; i < index; i++)
	{
		temp = temp->next;
	}

	return temp;
}

void insert(struct node** head, int index, char* str, char* type) // Write to index
{
	int i;

	struct node *last = (*head);

	// Construct new node to insert
	struct node *temp = (struct node*)calloc(1, sizeof(struct node));

	char *strBuffer = calloc(strlen(str), sizeof(char));
	char *typeBuffer = calloc(strlen(type), sizeof(char));

	strcpy(strBuffer, str);
	temp->str = strBuffer;
	strcpy(typeBuffer, type);
	temp->type = typeBuffer;

	if (index == 0)
	{
		temp->next = (*head);
		(*head) = temp;
	}
	else // need an out of range error //
	{
		for (i = 0; i < (index - 1); i++)
			last = last->next;

		temp->next = last->next;
		last->next = temp;
	}
}

// Searches a list for the searchTerm, either returns the node or NULL
struct node* search(struct node* head, char* searchTerm)
{
	struct node *temp;

	temp = head;

	while (temp != NULL)
	{
		if (CompareStrings(searchTerm, temp->str))
			return temp;

		temp = temp->next;
	}

	return NULL;
}


//Helper Functions

// Executes an operator on the surrounding terminals
void collapse(int index)
{
	//printList(lexemesHead);
	//printf("index = %d\n", index);

	int i = NULL;

	char* tempTerminal = NULL;
	tempTerminal = createTerminalString();

	struct node* terminalNode1 = NULL;
	struct node* operatorNode = dequeue(&lexemesHead, &lexemesCurrent, index);
	struct node* terminalNode2 = dequeue(&lexemesHead, &lexemesCurrent, index);

	// If semi then just go back and print the top of the stack
	if (CompareStrings(operatorNode->str, "NOT"))
	{
		printf("%s = xor i1 %s, 1\n", tempTerminal, terminalNode2->str);
	}
	else
	{
		struct node* terminalNode1 = dequeue(&lexemesHead, &lexemesCurrent, --index);

		// Act based ff the lexeme in the buffer
		if (CompareStrings(operatorNode->str, "PLUS"))
			printf("%s = add nsw i32 %s, %s\n", tempTerminal, terminalNode1->str, terminalNode2->str);
		else if (CompareStrings(operatorNode->str, "MINUS"))
			printf("%s = sub nsw i32 %s, %s\n", tempTerminal, terminalNode1->str, terminalNode2->str);
		else if (CompareStrings(operatorNode->str, "TIMES"))
			printf("%s = mul nsw i32 %s, %s\n", tempTerminal, terminalNode1->str, terminalNode2->str);
		else if (CompareStrings(operatorNode->str, "DIVIDE"))
			printf("%s = sdiv i32 %s, %s\n", tempTerminal, terminalNode1->str, terminalNode2->str);
		else if (CompareStrings(operatorNode->str, "MOD"))
			printf("%s = srem i32 %s, %s\n", tempTerminal, terminalNode1->str, terminalNode2->str);
		else if (CompareStrings(operatorNode->str, "LT"))
			printf("%s = icmp slt i32 %s, %s\n", tempTerminal, terminalNode1->str, terminalNode2->str);
		else if (CompareStrings(operatorNode->str, "GT"))
			printf("%s = icmp sgt i32 %s, %s\n", tempTerminal, terminalNode1->str, terminalNode2->str);
		else if (CompareStrings(operatorNode->str, "AND"))
			printf("%s = and i1 %s, %s\n", tempTerminal, terminalNode1->str, terminalNode2->str);
		else if (CompareStrings(operatorNode->str, "OR"))
			printf("%s = or i1 %s, %s\n", tempTerminal, terminalNode1->str, terminalNode2->str);
		else if (CompareStrings(operatorNode->str, "EQUALS"))
			printf("%s = icmp eq i32 %s, %s\n", tempTerminal, terminalNode1->str, terminalNode2->str);
		else if (CompareStrings(operatorNode->str, "NEQUALS"))
			printf("%s = icmp ne i32 %s, %s\n", tempTerminal, terminalNode1->str, terminalNode2->str);
		else
		{
			fprintf(stderr, "collapse error: \n\tfirst terminal, %s \n\toperator, %s\n\tsecond terminal, %s ", terminalNode1->str, operatorNode->str, terminalNode2->str);
			exit(-1);
		}
	}
	// Insert the new variable into the stack
	insert(&lexemesHead, index, tempTerminal, "TERMINAL");
}

// Loads all variables up to the index
void loadVariables(int endIndex)
{
	int i = 0;
	struct node* temp;

	for (i = 0; i <= endIndex; i++)
	{
		temp = peek(&lexemesHead, i);
		//printList(lexemesHead);

		if (CompareStrings(temp->type, "VARIABLE") && (peek(&lexemesHead, i + 1) == NULL || !CompareStrings(peek(&lexemesHead, i + 1)->str, "LPAREN")))
		{
			if (search(symbolTableHead, temp->str) == NULL)
			{
				fprintf(stderr, "error: use of undeclared variable %s", temp->str);
				exit(-1);
			}

			char* buffer = createTerminalString();
			printf("%s = load i32, i32* %%%s, align 4\n", buffer, temp->str);
			peek(&lexemesHead, i)->type = "TERMINAL";
			peek(&lexemesHead, i)->str = buffer;
		}
	}
}

// Match a char against the lexemes
struct node* matchChar(char symbol) // Expand into a char array for later implimentations
{
	int sym = symbol;
	struct node* temp = calloc(1, sizeof(struct node));
	char* buffer = calloc(7, sizeof(char));
	temp->type = "OPERATOR";

	switch (sym)
	{
	case '-':
		temp->precedence = 5;
		strcpy(buffer, "MINUS");
		temp->str = buffer;
		return temp;
	case '+':
		temp->precedence = 5;
		strcpy(buffer, "PLUS");
		temp->str = buffer;
		return temp;
	case '*':
		temp->precedence = 6;
		strcpy(buffer, "TIMES");
		temp->str = buffer;
		return temp;
	case '/':
		temp->precedence = 6;
		strcpy(buffer, "DIVIDE");
		temp->str = buffer;
		return temp;
	case '%':
		temp->precedence = 6;
		strcpy(buffer, "MOD");
		temp->str = buffer;
		return temp;
	case '(':
		temp->precedence = 300;
		strcpy(buffer, "LPAREN");
		temp->str = buffer;
		return temp;
	case ')':
		temp->precedence = -300;
		strcpy(buffer, "RPAREN");
		temp->str = buffer;
		return temp;
	case ';':
		temp->precedence = -300;
		strcpy(buffer, "SEMI");
		temp->str = buffer;
		return temp;
	case '=':
		temp->precedence = NULL;
		strcpy(buffer, "ASSIGN");
		temp->str = buffer;
		return temp;
	case '!': //precedence
		temp->precedence = 7;
		strcpy(buffer, "NOT");
		temp->str = buffer;
		return temp;
	case '{': //precedence
		temp->precedence = NULL;
		strcpy(buffer, "LCURLY");
		temp->str = buffer;
		return temp;
	case '}': //precedence
		temp->precedence = NULL;
		strcpy(buffer, "RCURLY");
		temp->str = buffer;
		return temp;
	case ',': //precedence
		temp->precedence = NULL;
		strcpy(buffer, "COMMA");
		temp->str = buffer;
		return temp;
	case ']': //precedence
		temp->precedence = NULL;
		strcpy(buffer, "RBRACE");
		temp->str = buffer;
		return temp;
	case '[': //precedence
		temp->precedence = NULL;
		strcpy(buffer, "LBRACE");
		temp->str = buffer;
		return temp;
	case '&': //precedence
		temp->precedence = 2;
		strcpy(buffer, "AND");
		temp->str = buffer;
		return temp;
	case '|': //precedence
		temp->precedence = 1;
		strcpy(buffer, "OR");
		temp->str = buffer;
		return temp;
	case '<': //precedence
		temp->precedence = 4;
		strcpy(buffer, "LT");
		temp->str = buffer;
		return temp;
	case '>': //precedence
		temp->precedence = 4;
		strcpy(buffer, "GT");
		temp->str = buffer;
		return temp;
	default:
		printf("\n Match Failure. Symbol: %c\n", symbol);
		return NULL;
	}
}

// Matches a string against the lexemes 4.0
struct node* matchString(char* string)
{
	if (string == NULL)
	{
		fprintf(stderr, "error: matchString handed NULL string");
		exit(-1);
	}

	if (CompareStrings(string, "print"))
	{
		struct node *temp = (struct node*)calloc(1, sizeof(struct node));
		char* buffer = calloc(6, sizeof(char));
		strcpy(buffer, "PRINT");
		temp->str = buffer;
		temp->next = NULL;
		return temp;
	}
	else if (CompareStrings(string, "read"))
	{
		struct node *temp = (struct node*)calloc(1, sizeof(struct node));
		char* buffer = calloc(5, sizeof(char));
		strcpy(buffer, "READ");
		temp->str = buffer;
		temp->next = NULL;
		return temp;
	}
	else if (CompareStrings(string, "int"))
	{
		struct node *temp = (struct node*)calloc(1, sizeof(struct node));
		char* buffer = calloc(4, sizeof(char));
		strcpy(buffer, "INT");
		temp->str = buffer;
		temp->next = NULL;
		return temp;
	}
	else if (CompareStrings(string, "return"))
	{
		struct node *temp = (struct node*)calloc(1, sizeof(struct node));
		char* buffer = calloc(7, sizeof(char));
		strcpy(buffer, "RETURN");
		temp->str = buffer;
		temp->next = NULL;
		return temp;
	}
	else if (CompareStrings(string, "if"))
	{
		struct node *temp = (struct node*)calloc(1, sizeof(struct node));
		char* buffer = calloc(7, sizeof(char));
		strcpy(buffer, "IF");
		temp->str = buffer;
		temp->next = NULL;
		return temp;
	}
	else if (CompareStrings(string, "else"))
	{
		struct node *temp = (struct node*)calloc(1, sizeof(struct node));
		char* buffer = calloc(7, sizeof(char));
		strcpy(buffer, "ELSE");
		temp->str = buffer;
		temp->next = NULL;
		return temp;
	}
	else if (CompareStrings(string, "while"))
	{
		struct node *temp = (struct node*)calloc(1, sizeof(struct node));
		char* buffer = calloc(7, sizeof(char));
		strcpy(buffer, "WHILE");
		temp->str = buffer;
		temp->next = NULL;
		return temp;
	}
	else // a variable name || a function name
	{
		struct node *temp = (struct node*)calloc(1, sizeof(struct node));
		char* buffer = calloc(strlen(string) + 1, sizeof(char));
		strcpy(buffer, string);
		temp->str = buffer;
		temp->next = NULL;
		temp->type = "VARIABLE"; //functions are variables followed by a LPAREN
		return temp;
	}
}

// Creates a number node for a given string 4.0
struct node* createNumber(char* string)
{
	if (string == NULL)
	{
		fprintf(stderr, "error: matchString handed NULL string");
		exit(-1);
	}

	struct node *temp = (struct node*)calloc(1, sizeof(struct node));
	char* buffer = calloc(strlen(string) + 1, sizeof(char));
	strcpy(buffer, string);
	temp->type = "NUMBER";
	temp->str = buffer;
	temp->next = NULL;
	return temp;
}

/*
returns the last index of the Expression that starts at index start
stops on paren if that flag is enabled
stops on comma if that flag is enabled
stops on semi if that flag is enabled
*/
int expressionEnd(int start, int parenFlag, int commaFlag, int semiFlag)
{
	int i = start;
	int parenCounter = 0;
	struct node* temp = peek(&lexemesHead, i);

	if (parenFlag)
	{
		while (1)
		{
			if (CompareStrings(temp->str, "RPAREN") && --parenCounter == 0)
				return i;
			else if (CompareStrings(temp->str, "LPAREN"))
				parenCounter++;

			temp = peek(&lexemesHead, ++i);
		}
	}
	else if (commaFlag)
	{
		while (1)
		{
			if (CompareStrings(temp->str, "RPAREN"))
				parenCounter--;
			else if (CompareStrings(temp->str, "LPAREN"))
				parenCounter++;
			else if (CompareStrings(temp->str, "COMMA") && (parenCounter == 0))
				return i;

			temp = peek(&lexemesHead, ++i);
		}
	}
	else if (semiFlag)
	{
		while (1)
		{
			if (CompareStrings(temp->str, "SEMI"))
				return i;

			temp = peek(&lexemesHead, ++i);
		}
	}
}

/*
	//HANDLE EQUALS     "=="
	//HANDLE NEQUALS    "!="
	//HANDLE AND        "&&"
	//HANDLE OR         "||"
	//HANDLE NEGITIVE	"-5"
*/
void HandleLexemeExceptions()
{
	int index = 0;
	struct node* temp1 = peek(&lexemesHead, index);
	struct node* temp2;

	while (temp1 != NULL && temp1->str != NULL) // Statements
	{


		if (CompareStrings(temp1->str, "AND"))
		{
			if (CompareStrings(temp1->next->str, "AND"))
				free(dequeue(&lexemesHead, &lexemesCurrent, index)); // Remove the redundant &&
			else
			{
				//error
			}
		}
		else if (CompareStrings(temp1->str, "OR"))
		{
			if (CompareStrings(temp1->next->str, "OR"))
				free(dequeue(&lexemesHead, &lexemesCurrent, index)); // Remove the redundant ||
			else
			{
				//error
			}
		}
		else if (CompareStrings(temp1->str, "ASSIGN"))
		{
			if (CompareStrings(temp1->next->str, "ASSIGN"))
			{
				free(dequeue(&lexemesHead, &lexemesCurrent, index)); // Remove the two = symbols
				free(dequeue(&lexemesHead, &lexemesCurrent, index));

				insert(&lexemesHead, index, "EQUALS", "OPERATOR");
				temp2 = peek(&lexemesHead, index);
				temp2->precedence = 3;
			}
		}
		else if (CompareStrings(temp1->str, "NOT"))
		{
			if (CompareStrings(temp1->next->str, "ASSIGN"))
			{
				free(dequeue(&lexemesHead, &lexemesCurrent, index)); // Remove the two = symbols
				free(dequeue(&lexemesHead, &lexemesCurrent, index));

				insert(&lexemesHead, index, "NEQUALS", "OPERATOR");
				temp2 = peek(&lexemesHead, index);
				temp2->precedence = 3;
			}
		}

		index++;
		temp1 = peek(&lexemesHead, index);
	}
}


//Core Functions

//Executes a fuction call Expression
void Function(int start)
{
	//printList(lexemesHead);
	char* functName = NULL;
	char* tempTerminal;
	int end, i;
	int commaFlag = 0;
	int parenCount = 0;
	struct node* temp = peek(&lexemesHead, start);
	int terms = 0;

	if (CompareStrings(peek(&lexemesHead, start)->type, "VARIABLE") && CompareStrings(peek(&lexemesHead, start)->next->str, "LPAREN"))
		functName = peek(&lexemesHead, start)->str;
	else
	{
		fprintf(stderr, "sanity error: no function name in FUNCTION");
		printList(lexemesHead);
		exit(-1);
	}

	if (CompareStrings(peek(&lexemesHead, start)->str, "mult"))
	{
	}

	free(dequeue(&lexemesHead, &lexemesCurrent, start)); //remove function name

	temp = peek(&lexemesHead, start);

	//Check for multiple terms
	do
	{
		if (CompareStrings(temp->str, "LPAREN"))
			parenCount++;
		else if (CompareStrings(temp->str, "RPAREN"))
			parenCount--;
		else if (CompareStrings(temp->str, "COMMA") && parenCount == 1)
			commaFlag++;

		temp = temp->next;
	} while (temp != NULL && parenCount && !commaFlag);

	if (commaFlag)
	{
		i = start;
		terms = 1;

		temp = peek(&lexemesHead, i);
		parenCount = 0;
		//printList(lexemesHead);

		do
		{
			if (CompareStrings(temp->str, "LPAREN"))
				parenCount++;
			else if (CompareStrings(temp->str, "RPAREN"))
				parenCount--;
			else if (CompareStrings(temp->str, "COMMA") && parenCount == 1)
			{
				terms++;
				// i = expressionEnd
				free(dequeue(&lexemesHead, &lexemesCurrent, i)); //remove COMMA
				Expression(start + 1, i - 1);
				inqueueN(dequeue(&lexemesHead, &lexemesCurrent, start + 1), &functionTermsCurrent, &fucntionTermsHead); // swap lists

				i = start + 1;
			}
			i++;
			temp = peek(&lexemesHead, i);
			// stops when it sees the second parenthesis
		} while (temp != NULL && parenCount);

		//printList(lexemesHead);
		free(dequeue(&lexemesHead, &lexemesCurrent, i - 1)); //remove RPAREN
		//printList(lexemesHead);
		free(dequeue(&lexemesHead, &lexemesCurrent, start)); //remove LPAREN
		//printList(lexemesHead);
		//Expression(start, i - 2);
		inqueueN(dequeue(&lexemesHead, &lexemesCurrent, start), &functionTermsCurrent, &fucntionTermsHead); // swap lists

		//

		tempTerminal = createTerminalString();
		printf("%s = call i32 @%s(", tempTerminal, functName);
		for (i = 0; i <= terms; i++)
		{
			printf("i32 %s", dequeue(&fucntionTermsHead, &functionTermsCurrent, 0)->str);
			terms--;
			if (terms > 0)
				printf(", ");
		}
		printf(")\n");

		//	printList(lexemesHead);
	}
	else
	{
		end = expressionEnd(start, 1, 0, 0);
		free(dequeue(&lexemesHead, &lexemesCurrent, end)); //remove RPAREN
		free(dequeue(&lexemesHead, &lexemesCurrent, start)); //remove LPAREN

		end -= 2;
		Expression(start, end);

		tempTerminal = createTerminalString();
		//printList(lexemesHead);
		printf("%s = call i32 @%s(i32 %s)\n", tempTerminal, functName, peek(&lexemesHead, start)->str);
		free(dequeue(&lexemesHead, &lexemesCurrent, start)); //remove temp terminal
	}

	insert(&lexemesHead, start, tempTerminal, "TERMINAL");
}

//Executes the Expression within it's given range
void Expression(int start, int end)
{
	int x, y;
	struct node* current;
	struct node* temp;

	// Handle Subexpressions
	for (x = start; x <= end; x++)
	{
		current = peek(&lexemesHead, x);

		if (CompareStrings(current->str, "LPAREN"))
		{
			y = expressionEnd(x, 1, 0, 0);

			dequeue(&lexemesHead, &lexemesCurrent, y); // remove last paren
			dequeue(&lexemesHead, &lexemesCurrent, x); // remove front paren
			Expression(x, y - 2);

			end -= y - x;
		}
		// function call
		else if (CompareStrings(current->type, "VARIABLE") && (current->next != NULL) && CompareStrings(current->next->str, "LPAREN"))
		{
			if (search(functionTableHead, current->str) == NULL)
			{
				fprintf(stderr, "error: use of undeclared function %s", current->str);
				exit(-1);
			}

			y = expressionEnd(x, 1, 0, 0);
			Function(x);

			end -= y - x;
		}
	}

	// Handle Not Unary Operator
	for (x = start; x <= end; x++)
	{
		current = peek(&lexemesHead, x);

		if (CompareStrings(current->str, "NOT"))
		{
			collapse(x);
			end--;
			x--;
		}
	}

	// Sanity Check, you SHOULD have a finished string here with only terminals and operators
	if (start != end && ((end - start) % 2))
	{
		fprintf(stderr, "error: length error in Expression\n");
		printList(lexemesHead);
		exit(-1);
	}

	int currentOperator = start + 1;
	int nextOperator = start + 3;

	while (1)
	{
		//printf("START: %d, END: %d, Nested: %d\n", start, end, ex);

		if (start == end)
			return;
		else if (nextOperator > end) // only one op
		{
			collapse(currentOperator);
			end -= 2;
			currentOperator = start + 1;
			nextOperator = start + 3;
		}
		else
		{
			if (peek(&lexemesHead, currentOperator)->precedence >= peek(&lexemesHead, nextOperator)->precedence)
			{
				collapse(currentOperator);
				end -= 2;
			}
			else
			{
				currentOperator = nextOperator;
				nextOperator += 2;
			}
		}
	}
}

//Executes the next statment in the queue
void Statement()
{
	int x, y, z;

	struct node* buffer = dequeue(&lexemesHead, &lexemesCurrent, 0);
	struct node *temp;

	if (CompareStrings(buffer->str, "INT"))
	{
		if (CompareStrings(lexemesHead->next->str, "LPAREN")) // Function Declaration
		{
			temp = dequeue(&lexemesHead, &lexemesCurrent, 0); //get function name
			
			// Multiple Funtion Names Check
			if (search(functionTableHead, temp->str) != NULL)
			{
				fprintf(stderr, "error: multiple definitions of %s", temp->str);
				exit(-1);
			}
			else
				inqueueS(temp->str, &functionTableCurrent, &functionTableHead);

			// begining
			printf("\n\ndefine i32 @%s(i32", temp->str); //wrong for multiple variables

			// free variables
			free(temp); //remove function name
			free(buffer); //remove INT
			free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove LPAREN

			// middle
			temp = lexemesHead;
			while (!CompareStrings(temp->str, "RPAREN"))
			{
				if (CompareStrings(temp->str, "COMMA"))
				{
					printf(", i32");
				}
				temp = temp->next;
			}

			// end
			printf(") {\n");

			

			int tempCounter = 0;
			while (CompareStrings(lexemesHead->str, "INT")) // int name comma
			{
				free(dequeue(&lexemesHead, &lexemesCurrent, 0));

				temp = dequeue(&lexemesHead, &lexemesCurrent, 0); // The VarName

				// Multiple Variables Check
				if (search(symbolTableHead, temp->str) != NULL)
				{
					fprintf(stderr, "error: multiple definitions of %s", temp->str);
					exit(-1);
				}

				inqueueN(temp, &symbolTableCurrent, &symbolTableHead);
				printf("%%%s = alloca i32\n", temp->str);
				printf("store i32 %%%d, i32* %%%s, align 4\n", tempCounter, temp->str);

				// Anouther Declaration
				if (CompareStrings(lexemesHead->str, "COMMA"))
				{
					tempCounter++;
					free(dequeue(&lexemesHead, &lexemesCurrent, 0));
				}
			}

			// Sanity Check
			if (CompareStrings(lexemesHead->str, "RPAREN"))
				free(dequeue(&lexemesHead, &lexemesCurrent, 0));
			else
			{
				fprintf(stderr, "sanity error: location: INT..LPAREN...RPAREN\n");
				printList(lexemesHead);
				exit(-1);
			}
		}
		else if (CompareStrings(lexemesHead->next->str, "SEMI")) // Variable Declaration
		{
			free(buffer); // Throw Out INT
			buffer = dequeue(&lexemesHead, &lexemesCurrent, 0); // The buffer now contains the name

			// Multiple Variables Check
			if (search(symbolTableHead, buffer->str) != NULL)
			{
				fprintf(stderr, "error: multiple definitions of %s", buffer->str);
				exit(-1);
			}

			buffer->type = "VARIABLE";

			inqueueN(buffer, &symbolTableCurrent, &symbolTableHead);
			printf("%%%s = alloca i32\n", buffer->str);

			// Sanity Check
			if (CompareStrings(lexemesHead->str, "SEMI"))
				free(dequeue(&lexemesHead, &lexemesCurrent, 0));
			else
			{
				fprintf(stderr, "sanity error: location: INT..SMI..SEMI\n");
				printList(lexemesHead);
				exit(-1);
			}
		}
		else
		{
			fprintf(stderr, "sanity error: location: INT..\n");
			exit(-1);
		}
	}
	else if (CompareStrings(buffer->str, "LCURLY") || CompareStrings(buffer->str, "RCURLY"))
	{
		free(buffer);
	}
	else if (CompareStrings(buffer->str, "IF"))
	{
		free(buffer); //remove IF

		if (CompareStrings(lexemesHead->str, "LPAREN")) // Sanity Check
		{
			x = expressionEnd(0, 1, 0, 0);
			free(dequeue(&lexemesHead, &lexemesCurrent, x)); //remove RPAREN
			free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove LPAREN
			loadVariables(x - 2); //load the variables needed

			Expression(0, x - 2); // Solve the boolean Expression
			char* tempstr = createTerminalString();

			x = ++LabelCounter;
			y = ++LabelCounter;
			z = ++LabelCounter; // reserved ELSE label

			printf("br i1 %s, label %%label%d, label %%label%d\n\n", lexemesHead->str, x, y);
			free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove disposed terminal

			printf("label%d:\n", x);
			if (CompareStrings(lexemesHead->str, "LCURLY"))
			{
				free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove LCURLY
				while (!CompareStrings(lexemesHead->str, "RCURLY"))
				{
					Statement();
				}
				free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove RCURLY
			}
			else
			{
				Statement();
			}

			// Handle condition of ELSE
			if (lexemesHead != NULL && CompareStrings(lexemesHead->str, "ELSE"))
			{
				free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove ELSE
				printf("br label %%label%d\n\n", z);

				printf("label%d:\n", y);
				if (CompareStrings(lexemesHead->str, "LCURLY"))
				{
					free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove LCURLY
					while (!CompareStrings(lexemesHead->str, "RCURLY"))
					{
						Statement();
					}
				}
				else
				{
					Statement();
				}
				printf("br label %%label%d\n\n", z);

				printf("label%d:\n", z);
			}
			else
			{
				printf("br label %%label%d\n\n", y);

				printf("label%d:\n", y);
			}
		}
		else
		{
			fprintf(stderr, "error: sanity check failed in IF statment");
			exit(-1);
		}
	}
	else if (CompareStrings(buffer->str, "WHILE"))
	{
		free(buffer); // Discard WHILE

		x = ++LabelCounter; //head
		y = ++LabelCounter; //body
		z = ++LabelCounter; //exit


		if (CompareStrings(lexemesHead->str, "LPAREN")) // Sanity Check
		{
			printf("br label %%head%d\n\nhead:\n", x);

			x = expressionEnd(0, 1, 0, 0);
			free(dequeue(&lexemesHead, &lexemesCurrent, x)); //remove RPAREN
			free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove LPAREN
			loadVariables(x - 2); //load the variables needed
			Expression(0, x - 2); // Solve the boolean Expression

			printf("br i1 %s, label %%body%d, label %%exit%d\n\n", lexemesHead->str, y, z);
			free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove disposed terminal

			printf("body%d:\n", x);
			if (CompareStrings(lexemesHead->str, "LCURLY"))
			{
				free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove LCURLY
				while (!CompareStrings(lexemesHead->str, "RCURLY"))
				{
					Statement();
				}
			}
			else
			{
				Statement();
			}

			printf("br label %%head%d\n\n", x);

			printf("exit%d:\n", z);
			free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove RCURLY
		}
		else
		{
			fprintf(stderr, "error: sanity check failed in WHILE statment");
			exit(-1);
		}
	}
	else if (CompareStrings(buffer->str, "PRINT"))
	{
		x = expressionEnd(0, 0, 0, 1);
		free(buffer); //remove PRINT
		free(dequeue(&lexemesHead, &lexemesCurrent, x)); //remove SEMI
		loadVariables(--x);

		Expression(0, x);
		printf("call void @print_integer(i32 %s)\n", lexemesHead->str);
		free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove temp
	}
	else if (CompareStrings(buffer->str, "READ"))
	{
		temp = search(symbolTableHead, lexemesHead->str);

		if (temp == NULL)
		{
			fprintf(stderr, "error: use of undeclared variable %s", buffer->str);
			exit(-1);
		}

		printf("%%t%d = call i32 @read_integer()\n", ++GlobalCounter);
		printf("store i32 %%t%d, i32* %%%s\n", GlobalCounter, temp->str);

		free(dequeue(&lexemesHead, &lexemesCurrent, 0)); // Trash variable
		free(dequeue(&lexemesHead, &lexemesCurrent, 0)); // Trash SEMI
	}
	else if (CompareStrings(buffer->str, "RETURN"))
	{
		Returned = 1;
		x = expressionEnd(0, 0, 0, 1);
		free(dequeue(&lexemesHead, &lexemesCurrent, x)); // remove the SEMI
		loadVariables(--x);
		Expression(0, x);

		printf("ret i32 %s\n}\n", lexemesHead->str);

		free(dequeue(&lexemesHead, &lexemesCurrent, 0)); // remove the temp variable
	}
	else if (CompareStrings(buffer->type, "VARIABLE"))
	{
		// Assign Statment
		if (CompareStrings(lexemesHead->str, "ASSIGN"))
		{
			if (search(symbolTableHead, buffer->str) == NULL)
			{
				fprintf(stderr, "error: use of undeclared variable %s", buffer->str);
				exit(-1);
			}

			free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove the ASSIGN
			x = expressionEnd(0, 0, 0, 1);
			loadVariables(x);
			free(dequeue(&lexemesHead, &lexemesCurrent, x)); //remove the SEMI

			Expression(0, --x);// Execute Following Expression

			printf("store i32 %s, i32* %%%s, align 4\n", lexemesHead->str, buffer->str);

			free(dequeue(&lexemesHead, &lexemesCurrent, 0)); //remove the tempTerminal
			free(buffer); //remove the variable name
		}
		// Function Call
		else if (CompareStrings(lexemesHead->str, "LPAREN"))
		{
			x = expressionEnd(0, 0, 0, 1);
			free(dequeue(&lexemesHead, &lexemesCurrent, x)); // remove the SEMI
			loadVariables(--x);
			Expression(0, x);

			free(dequeue(&lexemesHead, &lexemesCurrent, 0)); // remove any
		}
	}
	else
	{
		fprintf(stderr, "error: statment error on %s", buffer->str);
		exit(-1);
	}
}

// Opens the file, iterates through it parcing to lexemes
void LexCode(char* filename)
{
	FILE *fp;
	fp = fopen(filename, "r");
	// file error handling

	int prevPunct = 0;

	char currentInput;

	char* digitString = NULL;
	char* alphaString = NULL;

	struct node* temp;

	// Read the first character
	currentInput = fgetc(fp);

	while (1)
	{
		if (ispunct(currentInput))
		{
			// Built in # comment blocks
			if (currentInput == '#')
			{
				do
				{
					currentInput = fgetc(fp);
				} while (currentInput != '#');

				currentInput = fgetc(fp);
			}
			else
			{
				// If this is an overloaded minus indicating a negitive number
				if (lexemesCurrent != NULL && (prevPunct || CompareStrings(lexemesCurrent->str, "PRINT")) && currentInput == '-' && (!CompareStrings(lexemesCurrent->str, "RPAREN")))
				{
					digitString = (char*)calloc(2, sizeof(char));
					memcpy(digitString, &currentInput, 1);
				}
				else // Add the puct to the queue
					inqueueN(matchChar(currentInput), &lexemesCurrent, &lexemesHead);

				currentInput = fgetc(fp);
				prevPunct = 1;
			}
		}
		else if (isalpha(currentInput))
		{
			{
				do
				{
					if (alphaString == NULL) // Start the string
					{
						alphaString = (char*)calloc(2, sizeof(char));
						memcpy(alphaString, &currentInput, 1);
					}
					else // Add the new digit to the string
					{
						alphaString = (char*)realloc(alphaString, sizeof(char) * (strlen(alphaString) + 2));
						strncat(alphaString, &currentInput, 1);
					}
					// Read the next char
					currentInput = fgetc(fp);
				} while (isalpha(currentInput));

				inqueueN(matchString(alphaString), &lexemesCurrent, &lexemesHead);
				// Free alphaString for next pass
				free(alphaString);
				alphaString = NULL;
				prevPunct = 0;
			}
		}
		else if (isdigit(currentInput))
		{
			do
			{
				if (digitString == NULL) // Start the string
				{
					digitString = (char*)calloc(2, sizeof(char));
					memcpy(digitString, &currentInput, 1);
				}
				else // Add the new digit to the string
				{
					digitString = (char*)realloc(digitString, sizeof(char) * (strlen(digitString) + 1));
					strncat(digitString, &currentInput, 1);
				}

				// Read the next char
				currentInput = fgetc(fp);
			} while (isdigit(currentInput));

			inqueueN(createNumber(digitString), &lexemesCurrent, &lexemesCurrent);
			// Free digitString for next pass
			//free(digitString);
			digitString = NULL;
			prevPunct = 0;
		}
		else if (currentInput == EOF)
		{
			fclose(fp);
			HandleLexemeExceptions();
			return;
		}
		else // Whitespace, newline
		{
			// Read the next character
			currentInput = fgetc(fp);
		}
	}
}

int main(int argc, char *argv[])
{
	LexCode(argv[1]);

	// Function Program
	if (CompareStrings(lexemesHead->str, "INT") && CompareStrings(lexemesHead->next->next->str, "LPAREN"))
	{
		printf(PROJ4_PROLOGUE);

		int curlyCounter = 0;

		while (lexemesHead != NULL) // Execute All Statements
		{
			if (CompareStrings(lexemesHead->str, "LCURLY"))
				++curlyCounter;

			Statement();

			if (lexemesHead != NULL && CompareStrings(lexemesHead->str, "RCURLY") && --curlyCounter == 0)
			{

				Statement();

				if (!Returned)
					printf("ret i32 0\n}\n");

				while (symbolTableHead != NULL) // Frees the Symbol Table
					free(dequeue(&symbolTableHead, &symbolTableCurrent, 0));
			}
		}
	}
	// Non-Function Program
	else
	{
		printf(PROLOGUE);

		while (lexemesHead != NULL) // Execute All Statements
			Statement();

		while (symbolTableHead != NULL) // Frees the Symbol Table
			free(dequeue(&symbolTableHead, &symbolTableCurrent, 0));

		printf(EPILOGUE);
	}
}
